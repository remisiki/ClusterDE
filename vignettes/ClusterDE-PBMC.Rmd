---
title: "Perform ClusterDE on a PBMC dataset"
author: 
  - name: Dongyuan Song
    affiliation:
    - Department of Genetics & Genome Sciences, UConn Health 
    - Bioinformatics IDP, University of California, Los Angeles
    email: dongyuansong@ucla.edu
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('ClusterDE')`"
vignette: >
  %\VignetteIndexEntry{ClusterDE-PBMC_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
tools::R_user_dir("ClusterDE", which = "cache")
```

# Download data
The PBMC datasets are originally from `SeuratData`. We use one of them (10x Chromium (v3) from PBMC1 replicate). We filtered out some lowly epxressed genes to save computational time here.
```{r}
# InstallData("pbmcsca")
# data("pbmcsca")
# pbmc <- pbmcsca[, pbmcsca@meta.data$Method=="10x Chromium (v3)" & pbmcsca@meta.data$Experiment == "pbmc1"]
# 
# pbmc <- pbmc[Matrix::rowSums(pbmc@assays$RNA@counts) > 100, ]

# pbmc <- readRDS(url("https://figshare.com/ndownloader/files/41486283"))
data(pbmc, package = "ClusterDE")
```

# Run the regular Seurat pipeline

We perform the default Seurat clustering. Note that in real data analysis, the cell type label is usually unknown.

```{r fig.width=12, fig.height=6}
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
pbmc <- Seurat::UpdateSeuratObject(pbmc)
pbmc <- Seurat::NormalizeData(pbmc)
pbmc <- Seurat::FindVariableFeatures(pbmc)
pbmc <- Seurat::ScaleData(pbmc)
pbmc <- Seurat::RunPCA(pbmc)
pbmc <- Seurat::FindNeighbors(pbmc)
pbmc <- Seurat::FindClusters(pbmc, resolution = 0.3)
pbmc <- Seurat::RunUMAP(pbmc, dims = 1:10)
p1 <- Seurat::DimPlot(pbmc, reduction = "umap", label = T) +
  ggplot2::ggtitle("Clustering result") +
  Seurat::NoLegend()
p2 <- Seurat::DimPlot(pbmc, reduction = "umap", group.by = "CellType", label = T) +
  Seurat::NoLegend()
p1 + p2
```

In this vignette, we are interested in cluster 2 vs 8, which approximately represent CD14+/CD16+ monocytes. Please note that ClusterDE is designed for 1 vs 1 comparison. Therefore, users may (1) choose the two interested clusters manually based on their knowledge or (2) use the two locally closest clusters from computation (e.g., `BuildClusterTree` in `Seurat`).
```{r}
library(Seurat)
pbmc <- BuildClusterTree(pbmc)
PlotClusterTree(pbmc)
```

We perform the DE test between cluster 2 and 8. We subset the cluster 2 and 8 (`pbmc_sub`).
```{r}
pbmc_sub <- subset(x = pbmc, idents = c(2, 8))
# Remove genes with zero variance
non_zero_genes <- apply(Seurat::GetAssayData(pbmc_sub, layer = "counts"), 1, var) != 0
pbmc_sub <- pbmc_sub[non_zero_genes,]

original_markers <- Seurat::FindMarkers(
  pbmc_sub,
  ident.1 = 8,
  ident.2 = 2,
  min.pct = 0,
  logfc.threshold = 0
)
original_markers <- original_markers[original_markers$avg_log2FC > 0,]
```

# Find DEGs using ClusterDE

We can use `findMarkers()` to perform null-calibrated post-clustering differential expression. The result table is sorted by contrast scores.
```{r}
res <- ClusterDE::findMarkers(pbmc_sub, ident.1 = 8, ident.2 = 2)
head(res)
```

To compare the result from the naive Seurat pipeline and ClusterDE, we first visualize the top 6 DE genes from Seurat. Genes *LST1* and *RPS19* are both highly expressed in two clusters. In addition, *RPS19* is reported as a stable housekeeping genes in several studies. Note that it does not mean the expression levels of *LST1* and *RPS19* are the same between the two cell types. It means that they are not good cell type markers. Philosophically speaking, it means that **conditional on the two clusters are obtained by clustering algorithm, LST1 and RPS19 are less likely to be the cell type markers between the two cell types**.
```{r, fig.width=10, fig.height=6}
Seurat::FeaturePlot(pbmc[, pbmc$seurat_clusters %in% c(2, 8)], features = rownames(original_markers)[1:6], ncol = 3)
```
In contrast, the genes from ClusterDE do not have *LST1* and *RPS19* anymore.
```{r, fig.width=10, fig.height=6}
Seurat::FeaturePlot(pbmc[, pbmc$seurat_clusters %in% c(2, 8)], features = res$gene[1:6], ncol = 3)
```

# Customize null data generation

Here we show how ClusterDE generates and calculates the synthetic null data p-values. The synthetic null data is first generated based on the target data (real subset data, pbmc_sub, which contains the two clusters you are interested in). You can increase the number of cores (CPUs) to speed it up.
```{r}
null_data <- ClusterDE::constructNull(pbmc_sub, nCores = 1)
```

Next we perform the same preprocess pipeline for the null data as the target data, which is wrapped in `calcNullPval()`. This uses Louvain clustering in Seurat to adjust resolution until two clusters are found.
```{r}
null_pval <- ClusterDE::calcNullPval(null_data)
```

You can use `dimPlot()` to compare the reference (real) dataset and the synthetic null datasets generated by ClusterDE.
```{r, fig.width=10, fig.height=6}
ClusterDE::dimPlot(pbmc_sub, null_pval$data)
```

We extract the p-values from both original data and synthetic null data, then use ClusterDE to "compare" them.
```{r}
original_pval <- original_markers$p_val
names(original_pval) <- rownames(original_markers)
res <- ClusterDE::callDE(original_pval, null_pval$p)
```

The result table is the list of DEGs ranked by contrast scores, which is also used as the output of `findMarkers()`.
```{r}
head(res)
```

# PCA approximation for faster null data generation

For a more robust DEG detection, ClusterDE allows generating **multiple null data replicates**. By increasing number of `nRep` in `findMarkers()`, you can create several synthetic null datasets and compare all of them against the original DE markers. When generating many null data replicates (`nRep`) for DEG analysis, null data simulation can become time-consuming. ClusterDE provides a **PCA-based approximation** to speed up this process. By setting `flavour` to "pca" and increasing number of threads (`nCores`) in `findMarkers()`, the null datasets are generated faster while still preserving robustness.
```{r message=F, warning=F, results='hide'}
res <- ClusterDE::findMarkers(
  pbmc_sub,
  ident.1 = 8,
  ident.2 = 2,
  flavour = "pca",
  nRep = 40,
  nCores = 8
)
```

The `record` column counts the frequency with which each gene is identified as a DEG across null data replicates.

- A higher `record` value indicates that the gene is consistently called differentially expressed across multiple simulated null datasets.
- This metric helps assess the **stability and reproducibility** of DE calls.
```{r}
head(res)
```

We can also visualize the genes found by ClusterDE with multiple replicates and PCA approximation.
```{r fig.width=10, fig.height=6}
Seurat::FeaturePlot(pbmc[, pbmc$seurat_clusters %in% c(2, 8)], features = res$gene[1:6], ncol = 3)
```

To explicitly construct null data using PCA approximation, you can specify `usePca = T` and adjust number of PCs by changing `nPcs` in `constructNull()`.

```{r}
null_data <- ClusterDE::constructNull(pbmc_sub, usePca = T, nCores = 8, nRep = 40, nPcs = 200)
```

The returned `null_data` will contain a list of all replicates. Then we can use `calcNullPval()` to preprocess and calculate gene p-values for each replicate. Note that if PCA approximation is used, the simulated null data is not a true count matrix, so normalization should be skipped, and highly variable genes should be provided from real reference data.
```{r message=F, warning=F, results='hide'}
null_pval <- ClusterDE::calcNullPval(null_data, normalize = F, hvg = Seurat::VariableFeatures(pbmc_sub), nCores = 8)
```

Here we show part of the simulated null replicates in the same UMAP space as real data.
```{r fig.width=9, fig.height=6}
ClusterDE::dimPlot(pbmc_sub, null_pval$data[1:11])
```

# Session information
```{r}
sessionInfo()
```
